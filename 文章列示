浮点转十六进制:
/*作用:浮点数---转---十六进制 */
union fnum
{
long int m;
float f;
};
然后需要在引用的函数内声明共用体比如:
union fnum num;
用法:共用体是将 多个成员变量共用一个地址,并且同一时刻只允许1个成员变量被赋值,当某个成员变量修改后,其他的成员立刻改变,
比如:num.f=6.91;那么num.m=0x40DD1EB8;
当num.f=6.0时,另一个成员变量也改变num.m=40C00000
因为,单片机的十进制和十六进制都可以进行直接计算,所以用以上办法就可以实现浮点数转十六进制.
通俗的讲:共用体就像一个容器,成员变量就是不同形状的容器出口,当我们把1个圆形的物体放进去,如果这时我们像要一个方形的物体,那么就从方形的出口将物体取出,就得到方形了,
同理,我们要浮点转十六进制,就把浮点放进共用体(num.f=6.91),然后从整形取出( Rec=num.m )
细节问题:
因为浮点数转成十六进制后,通常都是32位数据,所以我们在取出整形数的时候要 用一个32位的变量(long int,或者u32 ) 去存.
2. 共用体和结构体的区别
　　共用体和结构体有下列区别:
　　1. 共用体和结构体都是由多个不同的数据类型成员组成,
　　但在任何同一时刻, 共用体只存放了一个被选中的成员, 而结构体的所有成员都存在。
　　2. 对于共用体的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了,
　　而对于结构体的不同成员赋值是互不影响的。 另外要注意的是，


计算串口接收到的浮点数:
我们通常在接收到串口的数字时, 基本上都是文本类型的数字, 并且是一位一位的文本,
比如6.19就是 ‘6’, ’.’ , ’1’ , ’9’
我们将它重新变为6.19需要进行一下操作:
Arr[]={‘6’,’.’,’1’,’9’}
1. 所有文本类型的数字只有 减零 之后才可以进行计算,否则是文本型.
  Arr[0]-‘0’;
2. 特别注意

sum_num= (float)(arr[6]-'0')+
(float)(arr[8]-'0')/10 +(float)(arr[9]-'0')/ 100;
在计算的时候,小数部分要转换成 小数,然后进行相加,
注意的是 在(float) (arr[8]-'0')/10的时候, 前面要先强制装换成(float)之后 才可以/10,这样才是把 1变成0.1,
如果在/10之前 没有(float)的话,意味着取10的倍数,
如果是 1/10,不加(float),那就等于0;最后相加就等于6.00000;
正确:
3. 注意细节:
成功将Arr[]={‘6’,’.’,’1’,’9’}
组合成sum_num =6.19之后, 在进行判断sum_num时:
if(sum_num == 62.91f) { LED1=0; }
注意这里的62.91后面加f,如果不加会报警告:
：单精度操作数隐式转换为双精度
当if(sum_num == 62.91) { LED1=0; }
这里的sum_num是浮点型,而62.91默认是双精度类型的;
当2个不同类型的变量 相加减时,会将二者都转换成较大一方的类型,
所以 浮点数 和 双精度进行判断时:浮点数会被转换成双精度.所以会报警告,告诉你这里进行了这样的操作.
当if(sum_num == 62.91f) { LED1=0; }这里的62.91f
是将62.91转换成浮点数
浮点数 和 浮点数进行判断 或者 计算,并不会转换成双精度,警告自然没了
下面附上 我自己研发的一些笔记，也都是经验
